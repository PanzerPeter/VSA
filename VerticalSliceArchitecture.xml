<?xml version="1.0" encoding="UTF-8"?>
<vertical_slice_guidelines version="2.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <metadata>
    <name>Vertical Slice Architecture</name>
    <created>2025-03-28</created>
    <updated>2025-06-17</updated>
    <scope>Software Architecture Pattern</scope>
  </metadata>
  
  <definition>
    <core_concept>Feature-oriented code organization rather than technical layers</core_concept>
    <organization>
      <principle>Group all components necessary for a specific feature together</principle>
      <principle>Ensure high cohesion within slices</principle>
      <principle>Maintain loose coupling between slices</principle>
    </organization>
    <example>
      <feature id="UserRegistration">
        <component type="controller">Registration controller</component>
        <component type="service">Registration service</component>
        <component type="repository">User repository access</component>
        <component type="model">User data models</component>
      </feature>
    </example>
  </definition>
  
  <problem_solving>
    <issue id="HighCoupling" severity="high">
      <description>Excessive dependencies between system parts</description>
      <solution>Isolate features into self-contained slices</solution>
      <impact>Minimizes risk of unintended side effects when making changes</impact>
    </issue>
    <issue id="LowCohesion" severity="high">
      <description>Related code scattered across technical layers</description>
      <solution>Colocate all code related to a specific feature</solution>
      <impact>Simplifies navigation and maintenance of features</impact>
    </issue>
    <issue id="UnnecessaryAbstractions" severity="medium">
      <description>Over-engineered interfaces and layers</description>
      <solution>Allow each slice to be tailored to its specific needs</solution>
      <impact>Reduces boilerplate code and improves development efficiency</impact>
    </issue>
  </problem_solving>
  
  <comparison target="LayeredArchitecture">
    <difference aspect="organization">
      <layered>Horizontal separation by technical concerns</layered>
      <vertical>Feature-based vertical organization</vertical>
    </difference>
    <difference aspect="coupling">
      <layered>High coupling within layers, low between layers</layered>
      <vertical>Tight coupling within slices, loose between slices</vertical>
    </difference>
    <difference aspect="change_impact">
      <layered>Changes may affect multiple features sharing a layer</layered>
      <vertical>Changes isolated to specific feature slices</vertical>
    </difference>
    <difference aspect="abstractions">
      <layered>Mock-heavy, rigid rules around dependency management</layered>
      <vertical>Most abstractions melt away, minimal cross-slice logic sharing</vertical>
    </difference>
    <difference aspect="approach_to_requests">
      <layered>Monolithic, less flexible, same approach for all requests</layered>
      <vertical>Treats each request as a distinct use case, tailored approach</vertical>
    </difference>
    <difference aspect="scalability">
      <layered>Less scalable, changes to shared code risk side effects</layered>
      <vertical>Scales well if team understands code smells and refactoring</vertical>
    </difference>
  </comparison>
  
  <benefits>
    <benefit id="Isolation" impact="high">
      <description>Changes to one feature are confined to its slice</description>
      <example>Adding validation rules affects only the relevant feature</example>
    </benefit>
    <benefit id="Simplicity" impact="medium">
      <description>Reduced cross-layer abstractions and boilerplate</description>
      <example>No need for generic repository interfaces shared across features</example>
    </benefit>
    <benefit id="Flexibility" impact="high">
      <description>Each slice can adopt appropriate design patterns</description>
      <example>Simple CRUD features use transaction scripts, complex workflows use DDD</example>
    </benefit>
    <benefit id="BusinessAlignment" impact="high">
      <description>Code organization mirrors business capabilities</description>
      <example>Developers can understand features end-to-end</example>
    </benefit>
    <benefit id="AgileAlignment" impact="high">
      <description>Feature-based organization aligns with agile practices</description>
      <example>Facilitates delivery of vertical slices of functionality in sprints</example>
      <insight>Enhances visibility and value delivery in sprint planning and delivery</insight>
    </benefit>
  </benefits>
  
  <drawbacks>
    <drawback id="DuplicationRisk" severity="medium">
      <description>Similar logic might be duplicated across slices</description>
      <mitigation>Extract shared utilities when duplication becomes problematic</mitigation>
      <example>Authentication or logging logic may be duplicated if not managed properly</example>
    </drawback>
    <drawback id="SkillDependency" severity="high">
      <description>Requires developers skilled in refactoring</description>
      <mitigation>Invest in training and code reviews</mitigation>
      <impact>Without refactoring skills, codebase might degrade over time</impact>
    </drawback>
    <drawback id="Inconsistency" severity="medium">
      <description>Different slices might be implemented differently</description>
      <mitigation>Establish coding standards and architectural guidelines</mitigation>
      <impact>Could complicate long-term maintenance without guidelines</impact>
    </drawback>
  </drawbacks>
  
  <cross_cutting_concerns>
    <concern type="logging">
      <approach>Inject logging interface into handlers</approach>
      <implementation>Avoid shared logging classes across slices</implementation>
      <pattern>Use structured logging with slice-specific context</pattern>
      <example>
        <![CDATA[
class CreatePostHandler:
    def __init__(self, logger):
        self.logger = logger
    
    def handle(self, command):
        self.logger.info("Creating post", {"feature": "create_post", "user_id": command.user_id})
        ]]>
      </example>
    </concern>
    <concern type="authorization">
      <approach>Use decorators or middleware at slice boundaries</approach>
      <pattern>Authorize at command/query level, not within handlers</pattern>
      <implementation>Apply authorization before slice execution</implementation>
      <example>
        <![CDATA[
@authorize_user
def create_post_endpoint(command):
    return CreatePostHandler().handle(command)
        ]]>
      </example>
    </concern>
    <concern type="caching">
      <approach>Slice-specific caching strategies</approach>
      <pattern>Cache at slice output level, not within handlers</pattern>
      <implementation>Use cache keys that include slice context</implementation>
    </concern>
    <concern type="validation">
      <approach>Validation specific to each slice's requirements</approach>
      <pattern>Validate input at slice entry point</pattern>
      <implementation>Allow different validation strategies per slice</implementation>
    </concern>
  </cross_cutting_concerns>
  
  <error_handling>
    <principle>Each slice handles its own errors appropriately</principle>
    <shared_exception_types>Domain exceptions and infrastructure failures only</shared_exception_types>
    <recovery_strategy>Fail fast within slices, handle gracefully at boundaries</recovery_strategy>
    <isolation>Slice failures should not cascade to other slices</isolation>
    <example>
      <![CDATA[
class CreatePostHandler:
    def handle(self, command):
        try:
            # Slice-specific validation and processing
            return self._create_post(command)
        except PostValidationError as e:
            # Handle slice-specific errors
            raise BusinessRuleViolation(f"Post creation failed: {e}")
        except DatabaseError as e:
            # Handle infrastructure errors
            raise InfrastructureFailure("Post creation unavailable")
      ]]>
    </example>
  </error_handling>
  
  <refactoring_indicators>
    <trigger threshold="3" type="duplication">
      <description>Same logic duplicated across slices</description>
      <action>Extract shared utility or service</action>
      <evaluation>Measure cost of duplication vs. coupling introduced</evaluation>
    </trigger>
    <trigger threshold="complexity" type="handler_size">
      <description>Handler exceeds 50 lines or 3 levels of nesting</description>
      <action>Break down into smaller components or extract domain services</action>
      <evaluation>Consider if complexity indicates need for richer domain model</evaluation>
    </trigger>
    <trigger threshold="dependencies" type="coupling">
      <description>Slice requires more than 5 external dependencies</description>
      <action>Evaluate if slice boundaries are correct</action>
      <evaluation>May indicate slice is too broad or cross-cutting concerns need addressing</evaluation>
    </trigger>
    <trigger threshold="change_frequency" type="maintenance">
      <description>Slice changes frequently due to similar requirements elsewhere</description>
      <action>Consider extracting common behavior</action>
      <evaluation>Balance between DRY principle and slice independence</evaluation>
    </trigger>
  </refactoring_indicators>
  
  <framework_patterns>
    <dotnet>
      <tool primary="MediatR">Command/query dispatch and pipeline behaviors</tool>
      <structure>Feature folders with embedded handlers and validators</structure>
      <example>
        <![CDATA[
// Features/CreatePost/CreatePostCommand.cs
public record CreatePostCommand(string Title, string Content) : IRequest<int>;

// Features/CreatePost/CreatePostHandler.cs
public class CreatePostHandler : IRequestHandler<CreatePostCommand, int>
{
    public async Task<int> Handle(CreatePostCommand request, CancellationToken cancellationToken)
    {
        // Implementation
    }
}
        ]]>
      </example>
      <pipeline>Use IPipelineBehavior for cross-cutting concerns</pipeline>
    </dotnet>
    <nodejs>
      <tool primary="Express">Route handlers as slice entry points</tool>
      <structure>Feature-based directory organization with handlers</structure>
      <example>
        <![CDATA[
// features/createPost/createPostHandler.js
class CreatePostHandler {
    async handle(command) {
        // Implementation
    }
}

// features/createPost/createPostRoute.js
router.post('/posts', async (req, res) => {
    const result = await new CreatePostHandler().handle(req.body);
    res.json(result);
});
        ]]>
      </example>
      <middleware>Use Express middleware for cross-cutting concerns</middleware>
    </nodejs>
    <python>
      <tool primary="FastAPI">Dependency injection and route organization</tool>
      <structure>Feature modules with handlers and dependencies</structure>
      <example>
        <![CDATA[
# features/create_post/handler.py
class CreatePostHandler:
    def __init__(self, db_session: Session):
        self.db_session = db_session
    
    def handle(self, command: CreatePostCommand) -> int:
        # Implementation
        pass

# features/create_post/router.py
@router.post("/posts")
async def create_post(
    command: CreatePostCommand,
    handler: CreatePostHandler = Depends()
):
    return handler.handle(command)
        ]]>
      </example>
      <dependency_injection>Use FastAPI's dependency system for slice composition</dependency_injection>
    </python>
    <java>
      <tool primary="Spring">Controller-Service-Repository per slice</tool>
      <structure>Package-by-feature organization</structure>
      <example>
        <![CDATA[
// features.createpost.CreatePostController
@RestController
@RequestMapping("/posts")
public class CreatePostController {
    private final CreatePostService service;
    
    @PostMapping
    public ResponseEntity<Integer> createPost(@RequestBody CreatePostCommand command) {
        return ResponseEntity.ok(service.handle(command));
    }
}
        ]]>
      </example>
      <configuration>Use Spring profiles for slice-specific configurations</configuration>
    </java>
  </framework_patterns>
  
  <performance_guidelines>
    <database>
      <principle>Each slice may have optimized queries for its specific use case</principle>
      <approach>Allow slice-specific query optimization over generic solutions</approach>
      <example>ListPosts slice uses read-optimized query while CreatePost uses write-optimized approach</example>
    </database>
    <caching>
      <principle>Slice-specific caching strategies over shared cache</principle>
      <approach>Cache at slice boundaries with feature-specific keys</approach>
      <example>Cache ListPosts results separately from GetPost results</example>
    </caching>
    <monitoring>
      <principle>Feature-level metrics and observability</principle>
      <approach>Track performance per slice rather than per technical layer</approach>
      <metrics>Response time, error rates, and throughput per feature</metrics>
    </monitoring>
    <scaling>
      <principle>Scale slices independently based on usage patterns</principle>
      <approach>Identify high-traffic slices and optimize specifically</approach>
      <example>Scale read-heavy slices differently from write-heavy slices</example>
    </scaling>
  </performance_guidelines>
  
  <suitability>
    <application_type id="WebApplications" fit="high">
      <rationale>Clear separation of distinct features or use cases</rationale>
    </application_type>
    <application_type id="Microservices" fit="high">
      <rationale>Aligns with bounded context principles</rationale>
    </application_type>
    <application_type id="AgileEnvironments" fit="high">
      <rationale>Facilitates incremental feature delivery</rationale>
      <detail>Enhances sprint planning and delivery by organizing around features</detail>
    </application_type>
    <application_type id="EventDrivenSystems" fit="high">
      <rationale>Natural fit for command/query patterns and event sourcing</rationale>
      <detail>Each slice can publish domain events independently</detail>
    </application_type>
    <application_type id="HighlyInterconnectedSystems" fit="low">
      <rationale>Managing shared components becomes cumbersome</rationale>
      <detail>Systems with predominant shared logic may face integration challenges</detail>
    </application_type>
    <application_type id="ReportingSystems" fit="medium">
      <rationale>Read-heavy systems benefit from query-specific optimizations</rationale>
      <detail>Each report can be optimized independently, but shared data models are common</detail>
    </application_type>
  </suitability>
  
  <related_patterns>
    <pattern id="CQRS" relationship="complementary">
      <description>Command Query Responsibility Segregation</description>
      <integration>
        <approach>Handle commands and queries as separate slices</approach>
        <example>Create order command and list orders query as distinct slices</example>
      </integration>
      <implementation_note>
        <framework>Naturally aligns with frameworks like MediatR for .NET or Axon for Java</framework>
        <pattern>Each slice corresponds to a specific command or query handler</pattern>
      </implementation_note>
    </pattern>
    <pattern id="CleanArchitecture" relationship="hybrid">
      <description>Separation of concerns into concentric layers</description>
      <integration>
        <approach>Apply Clean Architecture principles within each slice</approach>
        <example>Isolate domain logic from infrastructure within a slice</example>
      </integration>
      <distinction>
        <clean>Emphasizes concentric layers with strict dependency rules</clean>
        <vsa>Groups concerns by feature rather than by layer</vsa>
      </distinction>
    </pattern>
    <pattern id="FeatureDrivenDevelopment" relationship="complementary">
      <description>Agile methodology focusing on feature delivery</description>
      <integration>
        <approach>Structure codebase to mirror feature-based development</approach>
        <example>Each sprint feature corresponds to a vertical slice</example>
      </integration>
      <alignment>
        <methodology>Organizes development around feature lists and design-by-feature</methodology>
        <architecture>Structures codebase to mirror feature-based approach</architecture>
      </alignment>
    </pattern>
    <pattern id="EventSourcing" relationship="complementary">
      <description>Store state changes as a sequence of events</description>
      <integration>
        <approach>Each slice can produce and consume events independently</approach>
        <example>CreatePost slice emits PostCreated event, consumed by NotificationSlice</example>
      </integration>
    </pattern>
  </related_patterns>
  
  <implementation>
    <example language="python">
      <structure>
        <folder path="features/create_post">
          <file>create_post_command.py</file>
          <file>create_post_handler.py</file>
          <file>create_post_validator.py</file>
          <file>create_post_router.py</file>
        </folder>
        <folder path="features/list_posts">
          <file>list_posts_query.py</file>
          <file>list_posts_handler.py</file>
          <file>list_posts_router.py</file>
        </folder>
        <folder path="features/add_comment">
          <file>add_comment_command.py</file>
          <file>add_comment_handler.py</file>
          <file>add_comment_router.py</file>
        </folder>
      </structure>
      <code_sample feature="CreatePost">
        <![CDATA[
class CreatePostHandler:
    def __init__(self, db_session, logger, event_publisher):
        self.db_session = db_session
        self.logger = logger
        self.event_publisher = event_publisher
        
    def handle(self, command):
        try:
            self.validate(command)
            post = Post(title=command.title, content=command.content, author_id=command.author_id)
            self.db_session.add(post)
            self.db_session.commit()
            
            # Publish domain event
            self.event_publisher.publish(PostCreatedEvent(post.id, post.title, post.author_id))
            
            self.logger.info(f"Post created successfully: {post.id}")
            return post.id
        except ValidationError as e:
            self.logger.warning(f"Post creation validation failed: {e}")
            raise
        except Exception as e:
            self.logger.error(f"Post creation failed: {e}")
            self.db_session.rollback()
            raise
        ]]>
      </code_sample>
      <testing_approach>
        <strategy>Each slice can be unit-tested independently</strategy>
        <example>Testing CreatePostCommandHandler involves mocking only the database context, logger, and event publisher</example>
        <benefit>Simplifies testing by reducing dependencies and mocking requirements</benefit>
        <integration_testing>Test slice boundaries and cross-slice communication through integration tests</integration_testing>
      </testing_approach>
    </example>
    <shared_components>
      <component type="domain_model">
        <description>Core entities shared across multiple slices</description>
        <example>Post entity referenced by CreatePost and ListPosts slices</example>
        <guideline>Place in separate module, reference from multiple slices</guideline>
        <location>shared/models/ or domain/entities/</location>
      </component>
      <component type="utilities">
        <description>Common functionality extracted when duplication becomes problematic</description>
        <example>Authentication or validation utilities</example>
        <guideline>Extract only when duplication is clearly identified across slices</guideline>
        <threshold>Extract when same logic appears in 3+ slices</threshold>
      </component>
      <component type="infrastructure">
        <description>Technical services like database connections, external APIs</description>
        <example>Database session factory, HTTP client, message queue</example>
        <guideline>Inject as dependencies into slice handlers</guideline>
        <location>infrastructure/ or services/</location>
      </component>
    </shared_components>
  </implementation>
  
  <evolution_path>
    <stage id="initial" maturity="low">
      <description>Simple transaction scripts in each slice</description>
      <characteristic>Direct, procedural handlers with minimal abstraction</characteristic>
      <example>Basic CRUD operations with inline validation and data access</example>
    </stage>
    <stage id="intermediate" maturity="medium">
      <description>Refactored slices with domain patterns where needed</description>
      <characteristic>Domain services emerge for complex slices while simple ones remain as transaction scripts</characteristic>
      <example>Complex workflows use domain services, simple operations remain as transaction scripts</example>
    </stage>
    <stage id="advanced" maturity="high">
      <description>Rich domain model with patterns applied contextually</description>
      <characteristic>Full DDD tactical patterns for complex domains, simpler patterns elsewhere</characteristic>
      <example>Aggregates and domain events for complex features, simple handlers for CRUD</example>
    </stage>
    <guideline>Allow natural evolution based on complexity, resist premature abstraction</guideline>
    <decision_criteria>
      <complexity>Business logic complexity drives architectural sophistication</complexity>
      <change_frequency>Frequently changing slices benefit from richer domain models</change_frequency>
      <team_skills>Team capability influences appropriate abstraction level</team_skills>
    </decision_criteria>
  </evolution_path>
  
  <ai_coding_guidance>
    <preference>Favor explicit slice boundaries over implicit coupling</preference>
    <validation>Verify each slice can be understood independently</validation>
    <refactoring>Suggest extraction only when clear duplication patterns emerge</refactoring>
    <testing>Prioritize slice-level testing over integration testing</testing>
    <dependencies>Minimize cross-slice dependencies, prefer event-driven communication</dependencies>
    <naming>Use feature-based naming conventions that reflect business capabilities</naming>
    <documentation>Document slice responsibilities and boundaries clearly</documentation>
    <evolution>Recommend simpler patterns initially, evolve complexity as needed</evolution>
  </ai_coding_guidance>
  
  <training_resources>
    <skill id="Refactoring" priority="high">
      <resource type="book">Refactoring: Improving the Design of Existing Code by Martin Fowler</resource>
      <resource type="practice">Code kata exercises focusing on extract method and extract class</resource>
      <resource type="workshop">Team refactoring sessions on existing codebase</resource>
    </skill>
    <skill id="DomainModeling" priority="medium">
      <resource type="book">Domain-Driven Design by Eric Evans</resource>
      <resource type="practice">Event storming workshops for feature identification</resource>
      <resource type="workshop">Domain modeling exercises with business stakeholders</resource>
    </skill>
    <skill id="CodeSmells" priority="high">
      <resource type="reference">Code smell identification checklists</resource>
      <resource type="practice">Regular code review sessions focusing on smell detection</resource>
      <resource type="tool">Static analysis tools configured for architecture violations</resource>
    </skill>
  </training_resources>
  
  <anti_patterns>
    <anti_pattern id="SharedEverything">
      <description>Creating shared services used across multiple slices</description>
      <problem>Introduces coupling and reduces slice independence</problem>
      <solution>Duplicate simple logic, extract only when complexity justifies it</solution>
    </anti_pattern>
    <anti_pattern id="LayerLeakage">
      <description>Allowing infrastructure concerns to leak into slice handlers</description>
      <problem>Reduces testability and increases coupling</problem>
      <solution>Use dependency injection and abstractions at slice boundaries</solution>
    </anti_pattern>
    <anti_pattern id="SliceExplosion">
      <description>Creating too many small slices for trivial operations</description>
      <problem>Increases complexity without providing benefits</problem>
      <solution>Group related operations into single slices when appropriate</solution>
    </anti_pattern>
    <anti_pattern id="SliceMonolith">
      <description>Creating overly large slices that handle multiple concerns</description>
      <problem>Reduces cohesion and increases maintenance burden</problem>
      <solution>Split large slices based on business capabilities</solution>
    </anti_pattern>
  </anti_patterns>
</vertical_slice_guidelines>
